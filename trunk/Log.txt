Empezamos

Primeras tareas:
	- Definir estado posibles mechs
			- Guardar archivos con la armadura inicial
	- Hacer cono vision
	- distancia casillas

Pathfinder (battletech):
	Para la heuristica
	- Costo movimiento casillas (tablero) 
	- Distancia a casillas (clase tablero)
	- Capacidad de recibir disparo. (battletech)
	- Capacidad de dar disparo. (battletech)
	- Estado del contrario. (mech)
	- Estado propio.(mech)
	- Calor generado. (calculado por battletech)
	- Iniciativa.(configuracion juego)
	- Eleccion movimiento (andar,correr o saltar)
	- Encaramiento (mech)
**camino calculara el pathfinder. Se le pasara el tablero, el array de mech, el vector de iniciativa.

Fase reaccion (battletech)
	- cono vision (mech---> funcion que le pasas casilla y responde afirmativo si esta en el cono)

Fase disparo (mech)
	- distancia 
	- calor
	- capacidad acierto
**debera tener en cuenta si nos conviene disparar o esperarnos para luego golpear cuerpo a cuerpo

Fase ataque fisico(mech)
	- tener en cuenta calor


	------------------------------------------- ### Angel ### ----------------------------------


	Pathfinder (camino constructor)
	Heuristica:
		-INT Distancia (tablero) // devuelve numero de casillas de un punto p a q
		-INT Costo de movimiento (tablero) // devuelve un numero que es el costo de movimiento a esa casilla
		->Float Seguridad (BattleTech) // Probabilidad de que te disparen en media sobre 2d6
		->Float Capacidad de disparo (BattleTech) // Probabilidad de disparar en media sobre 2d6
		- INT Calor (camino [codigo]) // Puntos de calor por tipo de movimiento
		->Struct Estado del contrario (mech) // devuelve una estructura con enumerables con el daño sufrido por zonas del enemigo
			Añadir a los mech las funciones: estadoGeneralMech, estadoPartesMech
		->Struct Estado propio (mech) // idem para uno
		->Int Iniciativa (configuracionjuego) // devuelve un entero que indica cuando actuas
		-Tipo de movimiento(me [codigo])* //
		-Enum Encaramiento(mech && codigo) // indica a donde estas mirado

Reaccion	(BattleTech):
		-cono de visiones (mech [codigo])
Disparo (mech):
	-Con que disparar:
			-Distancia (tablero)
			-Calor (codigo)
			-Capacidad de acierto (codigo)
			-si no estamos en melee
Ataque fisico (mech):
		-Si se esta a melee
		-calor?¿


	------------------------------------------- ### Bitacora ### ----------------------------------
	- Tenemos que poner una descripcion de las funciones principales, para aclararnos entre nosotros

	- mira e puesto la lista de ficheros en "C:/ficheros/" asi pa tenerlos los dos en la misma ruta y que compile el ejecutable. Ademas te los mando por correo.
	a ender.mar.... 

	- escritura de fichero con los datos iniciales de las armaduras i su posterior lectura. Nombre de fichero "armaduraInicialJ<nº jugador>.sbt"

	- angel para saber si una zona esta en critico, o herido o tal, voi a acerlo en saltos de 5 puntos. El problema eske hay zonas que tienen eso o menos, pero tu
	dijiste de no hacerlo en proporcion, no?¿ mejor asi, en saltos de un determinado valor?¿ Es ke por ejemplo un mech ligero tiene nada de armadura.

	- Por cierto hay un problema que he detectado con los ficheros de armadura, y es que tienen que eliminarse despues de cada partida de forma manual, sino
	le programa falla. WEno no es que falle, es que cogera datos de armadura de un mech de otra partida

	- He pensado en hacer el que el nivel de daño por zona sea en proporcion, pero aparte tener una funcion que nos indique que tipo de armadura
	a nivel general que tiene cada bixo. (algo asi como indicarnos el tipo de mech que es de asalto, o ligero o pesado etc.) Voi a hacer pruebas para ver si mech
	del mismo tipo siguen una serie de "reglas" en cuanto a puntos de armadura para hacer una clasificacion. Estos son los datos obtenidos:
		Para mech asalto: 22,63 23,63 24,45 21
		Para mech ligeros: 7,72 2,36 4,54 7,36 6,09
		Para mech medios: 13,72 15,36 7,72 12,90
		Para mech pesados: 17,45   11,90 18,54 14,14  13,27
	Podriamos hacer una clasificacion de mech en tres: ligeros, medios y asalto o pesados. Con eso creo ke bastaria. La funcion se llamara tipoMech()  en la clase mech 
	devolvera un enum que se llame tipoMech.

	-He encontrado el siguiente dato buscando por ahi. Asi que el tipo de mech nos lo va a indicar el tonelaje del mech (eso implica que lo que habia exo antes ia no sirve ¬¬)
		Ligeros: 20 a 35 toneladas.
		Medios: 40 a 55 toneladas.
		Pesados: 60 a 75 toneladas.
		Asalto: 80 a 100 toneladas.

	- Por cierto hablando con mi cuñado (esta con la practica, tiene una ya hecha) me ha dicho que lo de armadura con los ficheros lo ve un poco locura, xk lo que tenemos
	que mirar es el nivel de blindaje actual, no ver que teniamos al principio i comparar, asike eso lo voi a kitar. E intentare medir de alguna manera nuestra salud solo
	teniendo en cuenta nuestro blindaje actual.

	-(Angel) si lo ves acomplcado quitalo pero no lo veia descabellado.
	-(Angel) Estuve trabajando en la linea de vision, no encuentro la razon matematica que me de el numero. 
	Si no lo logro esta noche are uno secuencial.
	-(Angel) Estaba pensando que la funcion de linea de vision si esta en linea de vision deveria devolver 0 si no esta y 
	un valor k de pntuacion (cerca, medio, lejos). 

	- (Antonio) si con la linea de vision te refieres al cono de vision, si estaria bien que devolviera a cuando se encuentra el enemigo
	-(Antonio ) Respecto a lo de los ficheros ia esta hecho lo que pasa es que lo voi a comentar, i si mas adelante nos hace falta lo usamos.
	- (Antonio) Voi a ver si pienso como detectar el grado de armadura, o poner algo en plan la salud del mech para saber como esta un mech para
	actuar en consonancia (para definir una estrategia, o saber cuando ir por un contrario o algo).

	-(Antonio) por cierto la funcion tipo de los mech te devuelve el tipo de mech que es: Ligero,Medio o Pesado. Al final solo e puesto estos tres
	porque con ello vale. Lo que devuelve es un dato de tipo enum tipoMech (esta en los structs, por si quieres verlo)

	- (Antonio) Oye para ver lo del grado de salud habia pensado en sumar todos los blindajes y tener un puntuacion en plan general, y en funcion de eso
	ya ver el estado en que se encuentra. Seria sin tener en cuenta las distintas partes. Luego podriamos tener un funcion para que nos avisara si una zona
	se queda sin blindaje, para ver si tenemos que soltar las armas que alli estuvieran hubicadas.

	- (Antonio) Respecto a lo de antes, he exo una simulacion y he visto que un mech estaba bastante mal, y todavia le quedaban muchos puntos de blindaje, debido
	a que las piernas las tenia intactas. Digo esto xk habia pensao en a la ora de hacer la suma esa generica no añadir el blindaje de las piernas, puesto que en 
	ellas no hay armas, y si te dan, no es tan peligroso como los otros sitios, que tienes radiadores, giroscopios... y es lo que creo que de verdad habria de tener
	en cuenta. Weno ya me dices que te parece la idea. (tengo una captura de pantalla que te mando al correo pa que veas a que me refiero). REspecto a esto tambien
	decirte que he visto en el libro que hasta con una sola pierna puedes seguir andando.

	-(Angel) Perdon por no haber hecho mucho aun, me puse a pensar sobre lo de el cono pero no surgio nada 5 horas perdidas. 
	No he tenido mucho tiempo desde que llegue (de hecho solo he tenido 2 dias normales) y uno fue ayer y el otro hoy, y bueno mañana voy a dressden
	asi que no creo hacer nada. Tratare de ponerme al dia pero seguramente no hasta que comience la escuela de verano pusto que en 2 dias ire a berlin (otra vez).
	Sobre lo que me dices confio en tu criterio pero todabia creo que deveriamos tener funciones que nos dijeran si podemos hacer daño mucho a una zona, 
	tal vez simplemente una que le reste a la armadura el daño del arma y nos devuelva ese valor. Lo digo para tener idea si podemos hacer mucho daño, incluso en las piernas porque 
	aunque no tengan nada si ellas no caminas. La funcion general esta bien, es deci la que suma todos los puntos al igal que esta bien la clasificacion.

	- (Antonio) Creo haber encontrado una forma de hacer el cono de vision, voy a ver si consigo terminarla en el finde.
	He conseguio hacer ia cuando el robot tiene encaramiento 1. Voi por los siguientes
	Encaramiento 4, Hecho
	Encaramiento 2, Hecho
	Encaramiento 3, Hecho
	Mañana lunes termino los otros dos
	Encaramiento 5 y 6 , HECHO
	CONO TERMINADO ^^ ha sido un coñazo enorme, pero ia esta, la funcion se tiene la siguiente cabecera y esta en mech, por si quieres verla:
		 public Boolean conoVision( Casilla casilla )

	- (Antonio) Te voi a explicar lo que se me ha ocurrido hacer para ver el estado de salud (estado blindaje). He pensado primero, en ver cada zona de forma independiente, y ver, en funcion
	de los puntos que tenga esa zona como me encuentro ( en una pierna el 100% es 30 puntos de golpe, mientras que la cabeza el 100% es 9). Luego una vez recogidos estos datos
	hacer una especie de media entre las posiciones. Ahora bien, como hay zonas mas importantes habia pensao en que algunas zonas tengan mas valor que otras. Asi por ejemplo,
	habia pensao que:
		- piernas : x1
		- brazos, torsos delantero y traseros: x 2
		- cabeza: x 3
		- torso central: x 4 (he puesto esto porque esta zona si se destruye el mech muere)
	Que te parece?¿ Para esto voi a tener que usar lo de los ficheros de la armadura inicial, pero weno.... Voi a ver si consigo implementarlo

	- (Antonio) Me parece mejor darle estos valores, pero a ver que opinas, es que tampoco creo ke necesitemos hilar tan fino, incluso podriamos fusionar
	el estado bueno y excelente
			    public enum estadoBlindaje
				{
					Excelente, //100%-80%
					Bueno, //80%-50%
					Medio, //50%-20%
					Malo, //20%-0%
					Nulo//0%
				};

	- (Antonio) He resuelto el problema de tener que borrar luego los ficheros de armadura a mano por lo de que para otra partida no sabiamos si eran
	nuestros datos o de otro robot de una partida antigua. Para ello lo que hago es meter el nombre del mech en el fichero, asi si al leer es de un nombre
	antiguo, cambiamos los datos.

	-(Antonio) Estoy intentando resolver el problema de como dar valores a cada zona segun importancia, ya que no encuentro una reparticion que me convenza.

	-(Antonio) He pensado la siguiente reparticion. La he puesto en sentido inverso, xk al hacer la media lo que hare sera truncar, con lo que siempre va,
	hacia el numero mas pequeño, y asi, al ponerlo en sentido inverso siempre nos saldra una estado mas negativo que positivo, lo que yo piendo que asi es preferible

				public enum estadoBlindaje
				{
					Nulo=1//0%
					Malo, //30%-0%
					Medio, //60%-30%
					Bueno, //100%-60%
				};

	-(angel) Hola estoy vivo, ya ve o que has trabajado me parece espupendo. Lo siento por no estar muy al corriente por aqui esoy muy ocupado.
	Ya veo que has hecho el cono de vision por lo que no se que hacer, creo que empezare con funciones que calculen la distancia.
	Por cierto sobre la funcion de cono de vision ¿para que le mandas una casilla si solo basta con la posicion? Digo no sobra solo era curiosidad.

	-(angel) Nesecito que me mandes o me digas donde puedo encontrar los datos de las casillas, me rfiero a la hojita que decia el costo de ir en bosque, terraseria, etc.
	esa hoja con el resumen que nome la traje.

	-(angel) Ya he hecho la distancia se llama int distanciaAB(posicion a, posicion b) (la he comentado es muy simple).

	-(angel) No entiendo el tipo de terreno hay 3 tipos despejado pavimentado y pantanoso el costo en el 1 y 2 es el mismo y el tercero no esta en ningun lado.
	-(angel) Por cierto estoy trabajando para hacer el cosot de un camino es decir 
			camino c; 
			c.costoMovimiento();
	la funcion devovleria un int con el costo de el camino.
	-(angel) Sobre el costo tengo un problema tengo que calcular el movimiento del encaramiento como la clase camino no lleva para cada paso un encaramiento solo puedo hacer dos cosas:
			>Que la funcion reciva como parametro el encaramiento inicial y el final, y los medios los calcula girando de forma natural (es decir si esta en la casilla 1115 encarado a la 5
			 y quiere ir 1114 girara 5->6->1 y luego avanzara).
			>La segunda opcion es alguna de estas tres: Crear, rescribir, crear una clase que herede de camino; cuya cual tenga una nueva clase que sea paso, el paso seria una tupla de 
			2 elementos una casilla y un encaramiento. No se si esto sera necesario para algun otro caso ademas de este, aunque puede que nos interese los encaramientos del medio 
			(por si queremos en un paso intermedio ir de espaldas o algo asi).
	Por ahora trabajare en el caso 1 porque requiere menos cambios por si la forma dos no te parece.
	-(angel) otra cosa el calculo de agua me lo invente, quiero decir, en el libro pone niveles del agua que van del 0 hasta el n y como yo entendi nosotros consideramos agua desde el -1 hasta -n,
	asi que supongo que el nivel 0 de agua es el nivel 0 y el 1 de agua es el -1 y asi con los demas. Si no es asi dime.
	
	-(angel) revise la funcion colindante de tablero.

	-(angel) he hecho tres funciones pero aun no se donde deverian de estar, tal vez en casilla todas pero bueno. Te las escribo y tu luego me dices donde cres.
			 (Casilla)public static  int costoMovimientoAB(Casilla de, Casilla a)<--esta calcula el costo de moverce entre dos casillas (para calcular el costo de movimiento relacionado con el nivel)
			 (camino)private int costoMovimiento(ArrayList camino)<--aun no la uso dado un array "camino" calcula su costo de movimiento
			 (camino)private int costoMovimiento(Casilla de, Casilla a) <---la usare en pathfinder calcula el costo total para moverce de una casilla a otra colindante (es decir puntos de movimientos por propiedades intrincecas(agua,escobros, etc) y relacionales (diferencia de niveles))
			 (Casilla)public int  costoMovimiento()<--- calcual el costo de movimiento intrinceco (es decir su costo estatico por sus propiedades y no por relacion a otra)
	movi la funcion que calcula la distancia heuristica de la clase tablero a camino y no se si hacerla privada.
	
	-(Angel) Creo que necesitamos o apliar la clase casilla crear una heredada. Porque necesito tener 3 datos el costo a moverme a ella desde el punto inicial (esto hay dos el costo intrinceco y el relacionado solo con la casilla actual [de la que vengo]), la heuristica y la suma de estas. Estoy pensando que puedo hacer una estructura, creo que eso hare por ahora. 

	-(angel) Sigo con el pathfinder, he hecho 3 funciones mas:
		private int mejorCasillaAbierta(ArrayList abiertas) <- esta me dice cual tine menor puntuacion f de las casillas abiertas
        private int estaEn(ArrayList lista, Casilla  elem) <- esta me dice que indice tinen el elemento elem en la array de heuristicas, si no esta devuelve -1
        private Boolean esta(ArrayList lista, Casilla elem) <- esta dice si un elemento esta en una matriz devolviendo true  si esta y false si no
	Todas en la clase pathfinder, y estan siendo utilizadas en la funcion pathfinder de la misma clase al igaul que todas las de costoMovimiento y distanciaAB.
	Agrege un atributo costoMovimiento que es el costo (en puntos de movimiento) de una casilla (solo los relacionados con la casilla), ademas una funcion que se llama costoMovimeto()
	que clcula el costo si no esta calculado antes si lo esta lo devuelve.

	he comentado lo mas posible la funcion pathfinder si la quieres mirar es corta (por ahora).

	-(angel) si llama un telefono desconocido a tu movil contesta!!!!! Soy yo!!!!

	- (antonio) wenas, te mandao un mail en el ke te e contao varias cosas, asike miralo ke no tengo ganas de volver a escribir. Voi a intentar organizar la clase battletech, para ponerle
	las funciones de las fases i demas rollos.

	- (antonio) oye e visto ke la funcion distancia la has metido en el camino. No deberia estar en el tablero?¿ voi a poner una copia alli i luego tu me dices, pero io creo ke eso es
	responsabilidad del tablero.

	- ( antonio ) He puesto en la clase BattleTech, la funcion faseMovimiento. Dentro de ella como hablamos es donde habra que llamar a funcion que busquen objetivos, 
	ke aga pathfinder y lo que haga falta.

	- ( antonio ) por cierto creo ke la funcion distancia esta mal, porque solo usas las columnas, haz pruebas, sobre el simulador. Yo me voi ia, mñn nos vemos

	-( angel ) en efecto esta mal ya la revise. 
	
	-(angel) Por amor de dios no empieces a cambiar cosas sin conectarte al msn y advertirme puesto que puedes dejarme colgado!!!!
	
	-(angel) Ya termine pathfinder tine algunos errores (no esta funcionando bien, o mas bien no funciona) pero ya termina. 
	Me fije que en depuracion comprobando 82 casillas abiertas casi ni tardo asi que no hay problemas de eficiencia.
	Creo que los errores estan en la funcion colindante, pero ya mañana depurare con atencion. Ademas hay cosas que tengo que corregir en la funcion pathfinder y el funcionamiento interno de colindante.

	- (antonio) Buenas angel, no se a ke te refieres con lo de cambiar cosas?¿, si no toque nada, lo unico fue copiar la funcion que tenias en Camino de distancia i ponerla tambien en Tablero, pero aparte de eso?¿
	Por otro lado e visto que la busqueda de casillas dentro de los arrays en las funciones es secuencial i pudiera ser un poco lento si se hace muchas veces, pero weno en caso de suceder el problema, ya buscaremos
	alguna forma mas rapida de guardarlo i luego saber si estan o no. (Como idea podriamos usar una matriz de booleanos o de enteros para ser 1 y 0, i asi saber de forma rapida si algo esta "marcado")

	- (antonio) Por cierto, te comente en el mensaje que quiza se me habia ocurrido una forma de realizar el algoritmo ( una especie de branch and bound ) para encontrar el camino. Voi a hacer unas pruebas para ver si es factible. Lo intentare hacer fuera de la clase Camino
	para que no interfiramos. Enga animo en la depuracion.

	- (antonio) Por cierto tienes que explicarme ke ace la funcion casillaColindante o colindante. Lo que hace es devolver la de enfrente?¿ Si es para hacer algo asi, podiamos tener en Tablero una serie de funciones que se les pase una casilla
	(la que estamos situados) y nos devuelva la de enfrente o la de la izquierda o la de la derecha o la de atras segun la funcion que sea.
	Si esta es tu funcion colindante:
			public Casilla colindante(Casilla actual, Encaramiento direccion)

	Las otras serian:
			public Casilla arriba(Casilla actual, Encaramiento direccion)
			public Casilla izquierda(Casilla actual, Encaramiento direccion)
			public Casilla derecha(Casilla actual, Encaramiento direccion)
			public Casilla atras(Casilla actual, Encaramiento direccion)

	Digo esto porque supongo ke necesitaras, las que estan situadas en estas posiciones para poder realizar todo el camino.
	Weno ya me dices i si kieres yo las realizo. Cuando puedas me lo dices.

	- ( antonio ) Weno como entrada resumen. ME voi a encargar en este orden:
		- Hacer lo de la media de la probabilidad de tiro.
		- Si kieres... las funciones esas para el tablero.
		- Luego implementar mi solucion de camino minimo (en caso de no haber terminado tu)
	Cualquier comentario ya me dices

	- (antonio) He visto mi posible solucion i creo ke al fin i al cabo era muy parecida, solo ke keria hacerlo sin mirar todo el mapa, i moviendome hasta donde pudiera.
	Pero kreo ke me corta caminos posibles. Asi de momento sigue tu, si te atrancas, pues lo intento, o sobre tu codigo, o empezando de nuevo. Intentare ir mirando tu codigo para
	comprenderlo. Enga ta lego

	11/8/10
	- (antonio) Wenas angel te he mandado a tu correo una documentacion interesante de otra practica de otro año. Esta bastante detallada y te puede ayudar para realizar el pathfinder puesto
	que explica la heuristica utilizada i todo. Tambien podria facilitarte el codigo, pero weno. Voi a hacer lo de las armas... dew

	- (antonio) Añadida a mech la funcion int maxAlcanceTiro(). Como te imaginas devuelve la maxima casilla a la que una de sus armas puede llegar a dar. La he pensado para ver cuando empezamos a entrar en el rango
	de accion de un mech. Las otras que teniamos eran medias de todas las armas, mientras que esta es devuelve la de maxima longitud.

	- (antonio) Por cierto estoi pensando que antes de realizar el camino en la fase de movimiento, deberiamos escoger la estrategia a seguir. Creo que quiza deberia haber un parametro mas para la funcion camino, que sea
	dicha estrategia, para tener en cuenta la heuristica de una manera u otra. Por ejemplo, si queremos ser ofensivos buscaremos zonas cercanas al mech y con mas altura, mientra que si queremos ser defensivos buscaremos zonas
	mas a cubierto y sobre todo mas alejadas.

	- ( antonio ) Por cierto he cambiado la zona donde hacias las pruebas de el camino minimo, te lo he puesto dentro de la funcion faseMoviemiento() (me refiero a cuando creabas la instancia dentro de BattleTech, para asi poder realizar io mis pruebas
	de las armas)

	-(antonio) He cambiado la funcion conoVision, para que reciba una posicion, ya que el mech lo que tiene asociado es una posicion, y no una casilla

	- (antonio) Oye mira los modificadores que tengo ke tener en cuenta para el disparo de cada arma, y eso suponiendo que estoi de frente al mech rival...
			/** MODIFICADORES PARA DISPARO
             * modificador distancia
             * " alcance minimo
             * " movimiento atacante
             * " movimiento objetivo
             * " terreno
             * " calor y daños
             * " objetivos inmoviles
             * " en suelo
             */
		Para hacerlo bien necesito la linea de vision, puesto que si hay coberturas parciales... pues hay modificadores, aparte de que podria no existir vision. Lo que podria hacer es una aproximacion... Pero el problema de hacer esto es que te puede llevar 
		a casillas que luego no tengan LdV con el objetivo. Entonces que hacemos?¿
		Ahora eso si, esta funcion va a tener que hacerse bien hecha de todas maneras para la fase de disparo con armas, pero claro ahi si se puede llamar a la LdV.exe puesto que la posicion sera ya fija.
		
		-(antonio) Viendo los problemas que tendremos para calcular esto, veo mejor no tener el cuenta el daño que podria hacer, puesto que no es posible calcularlo. Lo que puedes utilizar es cuando entra en el rango de accion de algun mech.
		Dado que ahora mismo no puedo ayudarte en el movimiento, puesto que asta que no ablemos no me voi a poner a toquetear tu codigo, lo que voi a hacer es empezar con la fase de ataque con armas.
		Cuando veas to esto, ve respondiendo una a una a todas las cuestiones que te haya podido plantear.

		- (antonio) he estado leyendo la documentacion que te he pasado, y ahi muchas cosas que nos pueden ayudar (en la fase de movimiento sobre todo). Asi que leelo.

		- (angel) Solo quieria decir que me dio un conflicto cuando hice un commit, y por ello agradeceria mucho que si estas trabajando te conectaras (msn) para que haga mas commits. 

		- (angel) Sobre los cambios en colindante para cambiarla puedes hacerlo pero no me es mas util que como esta ahora. Ya que al pasarle el encaramiento como un etero haciendo un casting, puedo meter la i como el encaramiento. 
		Aunque creo que es posible que colindante tenga fallos pero luego la depurare.

		- (angel) Sobre la busqueda secuencial no pensaba dejarla asi, cuando funcionara pensaba que podria seleccionar la mejor mientras selecionaba todas las abiertas; es decir durante el bucle principal. Pero por ahora no queria complicarme primero que funcione.
		El codigo actual solo es una aplicacion del pathfinder y no lo he depurado (se de hecho que esta mal).

		- (angel) sobre la heuristica primer quiero que funcione de la manera mas facil, cuando esto este hecho hare el siguiente paso que es incluir mas cosas.

		- (angel) sobre la LdV no se que decirte, tal vez puedes pedirle el codigo en java al profesro , no?

		12/8/10
		- (antonio) para que queremos ese codigo?¿ no nos vamos a poner a implementar nuestra solucion sobre eso, con lo mal que vamos de tiempo. Si en otros años an exo el a* sin tener en cuenta la probabilidad de disparo, nosotros tambien podemos hacerlo. Asi io creo
		que se debe poder hacer sin tener en cuenta eso. Si luego vemos como hacerlo es simplemente  es añadirle otro dato a la heuristica. Mientras, mirate como lo acen en la documentacion esa. Quiza te sirva de ayuda.
		Como ya te he dicho voi a empezar con la fase de ataque con armas, salvo ke tengas alguna objeccion, o prefieras que te ayude de alguna manera con el a*.
		Estare trabajando, dew.

		-(antonio) He modificado el constructor de camino para el programa que lee la LdV, porque tu ponias ke leyera el archivo de mapa "mapaJ1.sbt" mientras que dependiendo del jugador sera uno u otro. Por lo que le he añadido como parametro el numero de jugador a la funcion
		En la llamada quedaria algo asi: mapaJ"+jugador.ToString()+".sbt" etc.

		-(antonio) Añadido en structs.cs los siguiente:
			public enum Estrategia { 
				Ofensiva ,
				Defensiva ,
			};
		Aparte he puesto como atributo dentro de la clase Battletech un objeto de Estrategia, para las distintas fases.

		-(antonio) Voi a cambiar la funcion conoVision para que se le pase como argumento el encaramiento. Para que asi sirva para mirar el encaramiento del mech y tambien el encarmiento del torso. Que puede ser distintos

		-(antonio) Creo que voi a tener que hacer funciones para ver cuando un mech esta situado en el cono lateral (izq o drcha) o cuando esta situado a la espalda, para poder hacer la fase de armas.
		Por oi lo dejo, dew

		13/8/10
		-(antonio) Voi a cambiar las funciones del estado del mech. Porque ahora devuelvo un elemento del tipo enumerado estadoBlindaje. Lo que voi ha hacer es que devuelva una nota (un float) que ira sobre 10. Asi cada zona sera sobre 10,
		y luego para la nota global pues cada zona tendra un % hasta sumar el 100% (por ejemplo: Torso Central=15% - pierna izquierda=5% ). Tambien voi a hacer lo mismo para la estructura interna (hasta ahora solo tenia en cuenta blindaje)
		Tambien voi a asignar una nota segun el tipo de mech, siendo 10 el mech de asalto y 3 el mech ligero.
		Mi idea es luego coger estas tres notas parciales (blindaje, estructura interna y tipo mech) y formar una nota global sobre 10 que servira para determinar la estrategia que seguira el mech (ofensiva o defensiva). Esta idea la he cogido del documento
		que te envie por mail. Ya que creo que sale con mas sentido teniendo todo en una nota sobre 10, xk sale mas facil de manejar y comparar, y sobre todo es mas facil de entender. Cuando termine te mandare en un documento word la distribucin de que tanto 
		por ciento he dado a cada zona, para ver que opinas. Por supuesto, estos porcentajes se pueden modificar en funcion de los resultados empiricos.
		Despues de terminar esto, are el resto de conos de vision que me quedan (conoDerecha, conoIzquierda, conoTrasero).
		Por ultimo continuare con la fase de armas. 
		Voi a ver si entre este finde y el lunes termino por lo menos hasta los conos. Dew

		- (antonio) Cambios en las funciones de estado del mech hechos. La funcion final se llama nota() y devuelve un float. Lo que hace es:
			40% blindaje
			40% tipo mech
			20% esctructura interna
		Devuelve un float en [0-10], que nos servira para comparar mech y para establecer la estrategia a seguir. Mira las funciones por si quieres mirarlo, estan son:
			        public float tipo()
					public float nota()
					Todas las que estan dentro de la region estadoMech, que a su vez esta en la region metodos en la clase mech.cs
		Por hoy no hare mas, dew

		(15/08/10 angel) ya funciona el pathfinder basico. Necesito saber sobre que mapa estoy haciedo las pruebas, para ver si esta haceindolo del todo bien. Por lo menos parece que hace los caminos 
		de manera correcta. Voy a gregar una funcion que se llamara heuristica y alli debemos incluir los calculos para eleccion de casilla. Por ahora es solo la distancia (aproximada) al destino,
		pero debemos aumentar eso. La funcion sera un float, donde el minimo numero (inluyendo negativos) sera la mejor opcion. Por ahora estoy dando el valor a las casillas intransitables el valor int.MaxValue,
		ya que es el pero valor posible alcanzable. 

		Sobre por que negativos y por que float, la razon es sipmle: los valores de h por ahora estan entre 5 y 15 son muy bajos si queremos incluir muchas cosas creo que sera dificil no saturar los valor (aunque podemos multiplicaros).
		Pero si no queremos que lleguen a negativos siempre tendremos que tener cuidado de ver si en algun caso la suma nos pueda dar negativa (eso se puede si en la euristica solo sumamos y no damos puntos negativos, esto puede ser dificil).
		Lo de float porque si para darle mas marjen al rango de decicion sobre las casillas y reducir los empates.

		Por ello cambiare la struct heuristica y al valor h y f las cambiare por float. Si quieres puedes hacer tus pruebas, y dime si hay errores.

		Por cierto trate de cambiar la elecion de la casila mejor de las abiertas de forma que se hiciera durante la creaccion de la misma; pero la lista
		abiertas puede llegar a ser mas grade que el bulce que las va creando, de hecho casi siempre lo es. Esto se puede solucionar pre-rastreando las abiertas en el bucle y luego terminar fuera de el. Pero no se si 
		vale la pena el esfuerzo, por que no creo que el rastreo de una lista de a lo mucho 600  elementos (y esto es exagerando muchisisimo) sea mucho trabajo.

		(angel) descubri un error tonto en la construccion del camino, llamo a la funcion path finder pero esta no construlle nada. Miralo si quieres se arregla muy rapido pero tengo que irme ya.

		16/08/10
		- (antonio) Hola angel, me alegro que el pathfinde vaya saliendo, yo este finde no e podido hacer nada. 
		A ver, vamos por partes, en cuanto a lo del mapa para saber si lo hace bien no te hace falta, simplemente empieza una simulacion
		nueva en tu ordenador, eso si, el unico requisito de la partida es que el jugador designado como automatico se el numero 2, puesto que en el codigo esta puesto para que sea este, y que el fichero que le digas que
		es el jugador automatico (yo utilizo simplemente un .txt, y si kieres utilizar el ejecutable que te crea el visual, pues lo copias en la carpeta de los ficheros. Esto ultimo es lo que estoi haciendo para la fase de armas) 
		este en la carpeta C:/ficheros/, con eso ya puedes tu ir aciendo las pruebas que necesites sobre el mapa.
		Por otro lado, creo haber encontrado en que caso tu funcion distanciaAB falla, y creo que es cuando uno de los dos sumandos de la raiz es igual a cero, es decir o a.fila+b.fila==0 o a.columna+b.columna==0. Voi a seguir
		mirandolo y si veo un patron de fallo, lo corrijo. Por otro lado, creo ke esta funcion deberia pertenecer a la clase Posicion.cs, para que una posicion te diga a que distancia esta de otra dado que lo unico que usa es
		la fila y la columna, y esa informacion esta en posicion, y asi, si keremos usar esos datos para otras fases de movimiento u otros menesteres, pues se puede. Si detecto y corrijo el fallo pondre esta funcion en la clase
		posicion, y tu luego modificas el codigo del pathfinder para usar esta funcion, y asi no te toqueteo el codigo.

		En cuanto a lo de pre-rastrear y demas, de momento no nos complicaremos, y si vemos que el resultado final es lento, lo vemos.

		Por otro lado, te as mirao lo que te mande por mail?¿ En ese documento lo que utiliza es una zona de influencia para elegir la casilla destino (que se podria usar en el radio de nuestro mech o en el radio del mech rival).
		Que te parece usar esa idea?¿ Y lo que he hecho de cuantificar el estado del mech segun una nota del 0 al 10?¿ Respecto a esto en entradas anteriores te comente que habia una funcion nota, que devolvia la situacion del mech
		teniendo en cuenta el blindaje, la estructura y el tipo de mech que era. Habia pensado que si esa nota sale por encima de 7, tener una actitud ofensiva, y en caso opuesto actitud defensiva. Y que en funcion de esta actitud
		elijamos la casilla destino y el tipo de movimiento a realizar. Que te parece?¿ Cuando te conectes lo primero que tienes que hacer es contestar respuestas.


		- (antonio) Creo que puedo hacer que la distancia devuelva el entero exacto, que separa dos casillas.

		- (antonio) Weno despues de muchas vueltas, ya esta lista la siguiente funcion dentro de posicion
				public int distancia(Posicion b)
		ME he tirado toda la tarde para hacerla y al final... he hecho un plagio del proyecto que me pasaron, asi que no entiendo muy bien como lo hace, pero el caso es que funciona, ya que la e probado bastante. La he terminado cogiendo
		xk estaba ya desperado despues de dos horas i pico probando cosas xD, y lo que estaba consiguiendo era un codigo super lioso y enorme, mientras que este en unas cuentas lineas lo hace. Si quieres exale un vistazo, aunke sea por curiosidad.
		No lo HE SUSTITUIDO todavia en tu codigo de pathfinder, puesto que ahora esa funcion devuelve un entero, y antes tu lo tenias que devolviera un float, entonces no se como te variara el codigo.
		Por cierto, cuando copia tu funcion de distancia para tomarla como base me di cuenta que devolvias sqrt( dx^2 + dx^2 ), asi que ve probando todo para que luego  no nos volvemos locos buscando tonterias asi.
		Lo voi a dejar ya por oi, que son las 20.30 Tchüs